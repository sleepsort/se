#!/usr/bin/env vim

目前只实现的B树结点的增与查操作，删的操作没有写

B-tree的结构其实很简单，定义一个最小度数与最大度数，
每个结点有两个域：数据域，存放当前结点的元素，指针域，存放
子结点的指针(或id什么的)。指针域=数据域+1，并且对于数据域i，它正是
指针域i与i+1之间的分界点。进行元素查找时，正是利用这些分界点层层二分

每当插入结点时，按查找树的套路找到适合的结点，尝试插入。
如果结点的元素达到上限，就需要分裂并挤出一个上升结点。上升结点会进入父结点
对应的位置，相当于对父结点执行插入操作（因此该步骤是递归定义的）。当没有办法
上升时，说明分裂的元素是根了，这样就会生成一个新的，数据域大小为1的根。因此，B-tree
是一个向上生长的树。

在算法书的实现中，并不是每次插入才进行结点分裂的，因为这要递归地回溯父亲结点，需要在结点
中维护一个父结点的信息。算法书是这么做的：由于每次插入都需要一次搜索，干脆在搜索过程中
把刚满的结点给分裂了，这样，真正插入的时候，就不用考虑结点大小溢出的情况。这样还有一个
好处: 

"对于树而言，单向搜索是可以迭代操作的。"

因此，每一步，我只需要看当前的结点就可以了。对于B树，由于我们是边搜边拆的，如果某个结点要分裂，
只会上升到父结点，而父结点必然不会出现需要上升结点的情况。这样一来，回溯的过程就可以省掉了。
同时，我只需要在搜索的过程中把窗口放大一些，每步只看当前与父亲结点的情况，需要分裂结点作拆分，
需要查找二分查去，在实现上更为简明，而且还有一个好处，后面会提到。

之所以有B树这样的结构，原因有二：
  首先，这个树的结构可以保证结点的深度足够低，因为树是"由下往上"生长的，每一个结点都会连上相等深度的若干子树，
即使子树内部的元素个数不平衡，搜索深度是可以固定的。
  其次，这个树的结构可以保证局部性，以边搜边查的过程为例，每次需要考虑的结点至多三个（父结点，当前结点，
与当前结点的分裂），而由于父结点唯一的作用是用来改分裂结点后上升的值与新结点的指针域，因此，这个过程中
需要同时“看”的结点数只需要两个就够了。这也就意味着，如果内存太小，只纳得下两个结点的容量，利用磁盘作
结点缓存，在B树的结构下依然可以应对。因此，这个结构很适合用来把内存的开销摊给硬盘的需求。

一个完整的B树不是会分裂结点的数据结构，而是一棵树配上用于磁盘调度的页面管理器。
页面管理器需要实现的功能有：
  管理空闲页面，用于放置树的结点
  处理页面的使用情况，当页面上的结点被修改过，就需要写回磁盘，当页面已满，又需要使用新结点，
  就需要从空闲页面、当前未使用页面、可写回磁盘的页面中挑出合适的让新结点用。
  页面管理器是不应当知道结点的内部细节的。(不过，此处的实现中，还是把结点内部的id暴露出来。
  "千万千万要保证不能出现两个结点共用内存页的情况"

对应的，B树需要知道的，只是结点的内部细节，甚至不需要真正维护树的结构。（用逻辑的操作反映树的结构，
不必在内存中让每个结点都活起来，这应该是充分利用外存的一个思路基础吧）。B树需要严格按规则给结点
打脏页、空闲的标记，保证页面管理器的正常运作。



实现过程中用到的一些收获:
1. 边搜边拆的优化思想
2. jos页面管理器的那个优化，不用从头开始的循环查空页面，
   而是可以维护一个指针，下回接着扫
3. 脏页的标记很重要，每次都写磁盘开销很大的
4. 可以直接把一个结点转成void*写磁盘，方便暴力
5. 一棵树的中序序列+前序序列可以唯一表示该树，对于B树，前序序列是固定的，中序验证足矣
6. 定长的数组要注意下标... 
